seu <- FindSVGs(seu, nfeatures = 100)
# use SVGs to fit DR.SC model
# maxIter = 2 is only used for illustration, and user can use default.
seu1 <- DR.SC(seu, K=4,platform = 'ST', maxIter=2,variable.type = 'SVGs',verbose=FALSE)
toc <- proc.time()
toc - tic
tic <- proc.time()
seu <- gendata_RNAExp(height=10, width=10,p=50, K=4,platform="ST")
library(Seurat)
seu <- NormalizeData(seu)
# choose 100 highly variable features
# seu <- FindVariableFeatures(seu, nfeatures = 100)
# maxIter = 2 is only used for illustration, and user can use default.
# seu1 <- DR.SC(seu, K=4, platform = 'ST', maxIter=2,verbose=FALSE)
# choose spatially variable features
seu <- FindSVGs(seu, nfeatures = 40)
# use SVGs to fit DR.SC model
# maxIter = 2 is only used for illustration, and user can use default.
seu1 <- DR.SC(seu, K=4,platform = 'ST', maxIter=2,variable.type = 'SVGs',verbose=FALSE)
toc <- proc.time()
toc - tic
seu1
tic <- proc.time()
seu <- gendata_RNAExp(height=20, width=20,p=200, K=4)
library(Seurat)
seu <- NormalizeData(seu)
# choose 2000 variable features using Seurat
seu <- FindVariableFeatures(seu, nfeatures = 100)
# users define the adjoint matrix
Adj_sp <- getAdj(seu, platform = 'ST')
var.features <- seu@assays$RNA@var.features
X <- Matrix::t(LogNormalize(seu@assays$RNA@counts[var.features,],))
# maxIter = 2 is only used for illustration, and user can use default.
drscList <- DR.SC_fit(X,Adj_sp=Adj_sp ,K=4, maxIter=2, verbose=TRUE)
toc <- proc.time()
toc - tic
tic <- proc.time()
seu <- gendata_RNAExp(height=10, width=10,p=50, K=4)
library(Seurat)
seu <- NormalizeData(seu)
# choose 2000 variable features using Seurat
seu <- FindVariableFeatures(seu, nfeatures = 40)
# users define the adjoint matrix
Adj_sp <- getAdj(seu, platform = 'ST')
var.features <- seu@assays$RNA@var.features
X <- Matrix::t(LogNormalize(seu@assays$RNA@counts[var.features,],))
# maxIter = 2 is only used for illustration, and user can use default.
drscList <- DR.SC_fit(X,Adj_sp=Adj_sp ,K=4, maxIter=2, verbose=TRUE)
toc <- proc.time()
toc - tic
tic <- proc.time()
## we generate the spatial transcriptomics data with lattice neighborhood, i.e. ST platform.
seu <- gendata_RNAExp(height=20, width=20,p=200, K=4)
library(Seurat)
seu <- NormalizeData(seu)
# choose spatially variable features
seu <- FindSVGs(seu)
# use SVGs to fit DR.SC model
# maxIter = 2 is only used for illustration, and user can use default.
seu1 <- DR.SC(seu, K=4,platform = 'ST', variable.type = 'SVGs',maxIter = 2,verbose=FALSE)
drscPlot(seu1)
toc <- proc.time()
toc - tic
tic <- proc.time()
## we generate the spatial transcriptomics data with lattice neighborhood, i.e. ST platform.
seu <- gendata_RNAExp(height=10, width=10,p=50, K=4)
library(Seurat)
seu <- NormalizeData(seu)
# choose spatially variable features
seu <- FindSVGs(seu)
# use SVGs to fit DR.SC model
# maxIter = 2 is only used for illustration, and user can use default.
seu1 <- DR.SC(seu, K=4,platform = 'ST', variable.type = 'SVGs',maxIter = 2,verbose=FALSE)
drscPlot(seu1)
toc <- proc.time()
toc - tic
library(DR.SC)
### Check examples do not have errors
devtools::run_examples()
29103176/1024
29103176/1024/1024
7778540/1024/1024
library(DR.SC)
library(DR.SC)
library(DR.SC)
library(DR.SC)
library("DR.SC")
data("HCC1", package = 'DR.SC')
HCC1
# standard log-normalization
HCC1 <- NormalizeData(HCC1)
library(Seurat)
# standard log-normalization
HCC1 <- NormalizeData(HCC1)
# choose 2000 highly variable features
seu <- FindVariableFeatures(HCC1, nfeatures = 1000)
?DR.SC
### Given K
seu <- DR.SC(seu, K=6, platform = 'Visium',nfeatures=1000, variable.type = 'HVGs',verbose=F)
spatialPlotClusters(seu)
drscPlot(seu)
# choose 2000 spatially variable features
seus <- FindSVGs(seu, nfeatures = 1000)
### Given K
seus <- DR.SC(seus, K=6, platform = 'Visium', nfeatures=1000,
variable.type='SVGs', verbose=T)
spatialPlotClusters(seus)
seus
seus[['RNA']]@var.features
SVGs <- topSVGs(seus, ntop = 1000)
SVGs
SVGs <- topSVGs(seus, ntop = 1000)
seus[['RNA']]@var.features <- SVGs
seus
?FindAllMarkers
SVGs <- topSVGs(seus, ntop = 1000)
dat <- FindAllMarkers(seus, features = SVGs)
head(dat)
library(dplyr, verbose=F)
top2 <-  dat %>%
group_by(cluster) %>%
top_n(n = 2, wt = avg_log2FC)
top2
# standard scaling (no regression)
seus <- ScaleData(seus)
DoHeatmap(subset(seus, downsample = 500), features = top2$gene, size = 5)
# standard scaling (no regression)
seus <- ScaleData(seus)
DoHeatmap(subset(seus, downsample = 500), features = genes, size = 5)
genes <- top2$gene[seq(1, 12, by=2)]
RidgePlot(seus, features = genes, ncol = 2)
# standard scaling (no regression)
seus <- ScaleData(seus)
DoHeatmap(subset(seus, downsample = 500), features = genes, size = 5)
# Test functions ----------------------------------------------------------
### Given K
seu <- gendata_RNAExp(height=30, width=30,p=500, K=4,platform="ST")
library(DR.SC)
# Test functions ----------------------------------------------------------
### Given K
seu <- gendata_RNAExp(height=30, width=30,p=500, K=4,platform="ST")
library(Seurat)
seu <- NormalizeData(seu)
pos <- cbind(seu$row, seu$col)
start.radius=1
Adj_sp <- getneighborhood_fast(pos, radius=start.radius)
summary(rowSums(Adj_sp))
str(summary(rowSums(Adj_sp)))
summary(rowSums(Adj_sp))['Median']
Med <- summary(rowSums(Adj_sp))['Median']
radius.lower <- 1
radius.upper <- 50
start.radius <- 1
Med <- 0
while(Med > 4 && Med <6){
Adj_sp <- getneighborhood_fast(pos, radius=start.radius)
Med <- summary(rowSums(Adj_sp))['Median']
if(Med < 4){
radius.lower <- start.radius
start.radius <- (radius.lower + radius.upper)/2
}else if(Med >6){
radius.upper <- start.radius
start.radius <- (radius.lower + radius.upper)/2
}
message("Current radius is ", start.radius, '\n')
}
start.radius
Med
while(!(Med > 4 && Med <6)){
Adj_sp <- getneighborhood_fast(pos, radius=start.radius)
Med <- summary(rowSums(Adj_sp))['Median']
if(Med < 4){
radius.lower <- start.radius
start.radius <- (radius.lower + radius.upper)/2
}else if(Med >6){
radius.upper <- start.radius
start.radius <- (radius.lower + radius.upper)/2
}
message("Current radius is ", start.radius, '\n')
}
radius.lower
radius.upper
summary(rowSums(Adj_sp))['Median']
radius.lower <- 1
radius.upper <- 50
start.radius <- 1
Med <- 0
while(!(Med >= 4 && Med <=6)){
Adj_sp <- getneighborhood_fast(pos, radius=start.radius)
Med <- summary(rowSums(Adj_sp))['Median']
if(Med < 4){
radius.lower <- start.radius
start.radius <- (radius.lower + radius.upper)/2
}else if(Med >6){
radius.upper <- start.radius
start.radius <- (radius.lower + radius.upper)/2
}
message("Current radius is ", start.radius, '\n')
}
start.radius
Med
summary(rowSums(Adj_sp))['Median']
summary(rowSums(Adj_sp))
?getneighborhood_fast
?DR.SC::getneighborhood_fast
Adj_sp <- getAdj(seu)
library(DR.SC)
Adj_sp <- getAdj(seu)
Adj_sp <- getAdj(seu, platform = 'ST')
Adj_sp <- getAdj(seu, platform = 'Visisum')
Adj_sp <- getAdj(seu, platform = 'Visium')
Adj_sp <- getAdj(seu, platform = 'SeqFISH')
DR.SC:::getAdj.Seurat
Adj_sp <- getAdj(seu, platform = 'SeqFISH')
obj <- seu
platform = 'SeqFISH'
platform %in% c("seqFISH", 'merFISH', 'Slide-SeqV2', 'SeqScope')
Adj_sp <- getAdj(seu, platform = 'seqFISH')
getAdj_auto <- function(obj, platform ='seqFISH'){
if (!inherits(obj, "matrix"))
stop("method is only for  matrix object!")
radius <- Find.radiusfunction(obj)
Adj_sp <- getneighborhood_fast(obj, radius=radius)
return(Adj_sp)
}
Adj_sp <- getAdj(seu, platform = 'seqFISH')
library(DR.SC)
Adj_sp <- getAdj(seu, platform = 'seqFISH')
getAdj_auto <- function(obj, platform ='seqFISH'){
if (!inherits(obj, "matrix"))
stop("method is only for  matrix object!")
radius <- Find.radius(obj)
Adj_sp <- getneighborhood_fast(obj, radius=radius)
return(Adj_sp)
}
Adj_sp <- getAdj(seu, platform = 'seqFISH')
toupper(platform)
(tolower(platform) %in% c("seqfish", 'merfish', 'slide-seqv2', 'seqscope')
)
Adj_sp <- getAdj(seu, platform = 'seqFISH')
library(DR.SC)
Adj_sp <- getAdj(seu, platform = 'seqFISH')
library(DR.SC)
Adj_sp <- getAdj(seu, platform = 'seqFISH')
obj
pos <- cbind(row=obj$row, col=obj$col)
Adj_sp <- getAdj_auto(pos, platform = platform)
## Bisection method to search the optimal radius to make the  median of neighborhoods between 4~6.
Find.radius <- function(pos){
if (!inherits(pos, "matrix"))
stop("method is only for Seurat or matrix objects!")
radius.lower <- 1
radius.upper <- 50
start.radius <- 1
Med <- 0
while(!(Med >= 4 && Med <=6)){
Adj_sp <- getneighborhood_fast(pos, radius=start.radius)
Med <- summary(rowSums(Adj_sp))['Median']
if(Med < 4){
radius.lower <- start.radius
start.radius <- (radius.lower + radius.upper)/2
}else if(Med >6){
radius.upper <- start.radius
start.radius <- (radius.lower + radius.upper)/2
}
message("Current radius is ", start.radius, '\n')
}
return(start.radius)
}
Adj_sp <- getAdj_auto(pos, platform = platform)
Adj_sp <- getAdj(seu, platform = 'seqFISH')
if (!inherits(obj, "Seurat"))
stop("method is only for Seurat or matrix objects")
# require(Matrix)
if (platform == "Visium") {
## Spots to left and right, two above, two below
offsets <- data.frame(x.offset=c(-2, 2, -1,  1, -1, 1),
y.offset=c( 0, 0, -1, -1,  1, 1))
} else if (platform == "ST") {
## L1 radius of 1 (spots above, right, below, and left)
offsets <- data.frame(x.offset=c( 0, 1, 0, -1),
y.offset=c(-1, 0, 1,  0))
}else if(tolower(platform) %in% c("seqfish", 'merfish', 'slide-seqv2', 'seqscope')){
pos <- cbind(row=obj$row, col=obj$col)
Adj_sp <- getAdj_auto(pos, platform = platform)
return(Adj_sp)
}else {
stop(".find_neighbors: Unsupported platform \"", platform, "\".")
}
getAdj.Seurat <- function(obj, platform ='Visium'){
if (!inherits(obj, "Seurat"))
stop("method is only for Seurat or matrix objects")
# require(Matrix)
if (platform == "Visium") {
## Spots to left and right, two above, two below
offsets <- data.frame(x.offset=c(-2, 2, -1,  1, -1, 1),
y.offset=c( 0, 0, -1, -1,  1, 1))
} else if (platform == "ST") {
## L1 radius of 1 (spots above, right, below, and left)
offsets <- data.frame(x.offset=c( 0, 1, 0, -1),
y.offset=c(-1, 0, 1,  0))
}else if(tolower(platform) %in% c("seqfish", 'merfish', 'slide-seqv2', 'seqscope')){
pos <- cbind(row=obj$row, col=obj$col)
Adj_sp <- getAdj_auto(pos, platform = platform)
return(Adj_sp)
}else {
stop(".find_neighbors: Unsupported platform \"", platform, "\".")
}
## Get array coordinates (and label by index of spot in SCE)
spot.positions <- as.data.frame(cbind(row=obj$row, col=obj$col))
spot.positions$spot.idx <- seq_len(nrow(spot.positions))
## Compute coordinates of each possible spot neighbor
neighbor.positions <- merge(spot.positions, offsets)
neighbor.positions$x.pos <- neighbor.positions$col + neighbor.positions$x.offset
neighbor.positions$y.pos <- neighbor.positions$row + neighbor.positions$y.offset
## Select spots that exist at neighbor coordinates
neighbors <- merge(as.data.frame(neighbor.positions),
as.data.frame(spot.positions),
by.x=c("x.pos", "y.pos"), by.y=c("col", "row"),
suffixes=c(".primary", ".neighbor"),
all.x=TRUE)
## Shift to zero-indexing for C++
#neighbors$spot.idx.neighbor <- neighbors$spot.idx.neighbor - 1
## Group neighbor indices by spot
## (sort first for consistency with older implementation)
neighbors <- neighbors[order(neighbors$spot.idx.primary,
neighbors$spot.idx.neighbor), ]
df_j <- split(neighbors$spot.idx.neighbor, neighbors$spot.idx.primary)
df_j <- unname(df_j)
## Discard neighboring spots without spot data
## This can be implemented by eliminating `all.x=TRUE` above, but
## this makes it easier to keep empty lists for spots with no neighbors
## (as expected by C++ code)
## df_j <- map(df_j, function(nbrs) discard(nbrs, function(x) is.na(x)))
df_j <- lapply(df_j, function(nbrs) discard(nbrs, function(x) is.na(x)))
## Log number of spots with neighbors
n_with_neighbors <- length(keep(df_j, function(nbrs) length(nbrs) > 0))
message("Neighbors were identified for ", n_with_neighbors, " out of ",
ncol(obj), " spots.")
n <- length(df_j)
D <- matrix(0,  nrow = n, ncol = n)
for (i in 1:n) {
if(length(df_j[[i]]) != 0)
D[i, df_j[[i]]] <- 1
}
ij <- which(D != 0, arr.ind = T)
Adj_sp <- sparseMatrix(ij[,1], ij[,2], x = 1)
return(Adj_sp)
}
pos <- as.matrix(cbind(row=obj$row, col=obj$col))
Adj_sp <- getAdj_auto(pos, platform = platform)
library(DR.SC)
Adj_sp <- getAdj(seu, platform = 'seqFISH')
Adj_sp <- getAdj(seu, platform = 'slide-seqv2')
Adj_sp
library(DR.SC)
?getAdj
# Test functions ----------------------------------------------------------
### Given K
seu <- gendata_RNAExp(height=30, width=30,p=500, K=4,platform="ST")
library(Seurat)
seu <- NormalizeData(seu)
pos <- cbind(seu$row, seu$col)
Adj_sp <- getAdj(seu, platform = 'slide-seqv2')
Adj_sp <- getAdj(seu, platform = 'ST')
Adj_sp <- getAdj(seu, platform = 'Seqscope')
Adj_sp <- getAdj(seu, platform = 'slide-seqv2')
library(DR.SC)
# choose 400 highly variable features
seu <- FindVariableFeatures(seu, nfeatures = 400)
seu <- DR.SC(seu, K=7, platform = 'seqscope', verbose=T)
mclust::adjustedRandIndex(seu$spatial.drsc.cluster, dat$cluster)
mclust::adjustedRandIndex(seu$spatial.drsc.cluster, seu$true_clusters)
seu <- DR.SC(seu, K=7, platform = 'ST', verbose=T)
mclust::adjustedRandIndex(seu$spatial.drsc.cluster, seu$true_clusters)
?getAdj_auto
library(DR.SC)
?getAdj
?FindSVGs
library(DR.SC)
example("FindSVGs")
head(seu[['RNA']]@meta.features)
order(c(1,2,NA))
order(c(NA,2,NA))
library(DR.SC)
example("topSVGs")
genes <- topSVGs(seu, ntop=2)
genes
seu[['RNA']]@meta.features$order.SVGs
genes <- topSVGs(seu, ntop=95)
genes
order(seu[['RNA']]@meta.features$order.SVGs)
ntop <- 95
order(seu[['RNA']]@meta.features$order.SVGs)[1:ntop]
topSVGs <- function(seu, ntop=5){
if (!inherits(seu, "Seurat"))
stop("method is only for Seurat objects")
if(ntop > nrow(seu)) warning(paste0("Only ", nrow(seu), ' SVGs will be returned since the number of genes is less than ', ntop, '\n'))
SVGs <- row.names(seu)[seu@assays$RNA@meta.features$is.SVGs]
order_features <- seu[['RNA']]@meta.features$order.SVGs
idx <- order(order_features[!is.na(order_features)])[1:ntop]
SVGs[idx]
}
genes <- topSVGs(seu, ntop=95)
genes
library(DR.SC)
library(DR.SC)
?DR.SC
simulDRcluster
warning(paste0('There are ', sum(sd_zeros==0), 'zero-variance genes that will be removed'))
library(DR.SC)
library(DR.SC)
?getAdj
getneighborhood_fast
library(DR.SC)
library(DR.SC)
library(DR.SC)
library(DR.SC)
# Test functions ----------------------------------------------------------
### Given K
seu <- gendata_RNAExp(height=30, width=30,p=500, K=4,platform="ST")
library(Seurat)
seu <- NormalizeData(seu)
pos <- cbind(seu$row, seu$col)
Adj_sp <- getAdj(seu, platform = 'ST')
Adj_sp <- getAdj(seu, platform = 'Seqscope')
Adj_sp <- getAdj(seu, platform = 'slide-seqv2')
X <- t(LogNormalize(seu@assays$RNA@counts[var.features,],))
nfeatures <- 2000
# choose 2000 variable features, which includes 1000 mouse genes.
seu <- FindVariableFeatures(seu, nfeatures = nfeatures)
var.features <- seu@assays$RNA@var.features
X <- t(LogNormalize(seu@assays$RNA@counts[var.features,],))
library(Matrix)
X <- t(LogNormalize(seu@assays$RNA@counts[var.features,],))
head(X)
dim(X)
X[,1:4] <- 0
resList <- DR.SC_fit(X, K=4)
??DR.SC_fit
??DataFrame
library(DR.SC)
library(DR.SC)
library(DR.SC)
# Test functions ----------------------------------------------------------
### Given K
seu <- gendata_RNAExp(height=30, width=30,p=500, K=4,platform="ST")
library(Seurat)
seu <- NormalizeData(seu)
pos <- as.matrix(cbind(seu$row, seu$col))
Adj_sp <- getAdj(seu, platform = 'ST')
Adj_sp <- getAdj(seu, platform = 'Seqscope')
Adj_sp <- getAdj(seu, platform = 'slide-seqv2')
DR.SC:::getneighborhood_fast(cbind(1:4,2:5),10)
# choose 400 highly variable features
seu <- FindVariableFeatures(seu, nfeatures = 400)
seu <- DR.SC(seu, K=NULL,K_set=2:3,  parallel="parallel", platform = 'ST', verbose=T)
seu <- DR.SC(seu, K=7, platform = 'seqscope', verbose=T)
mclust::adjustedRandIndex(seu$spatial.drsc.cluster, seu$true_clusters)
seu <- DR.SC(seu, K=7, platform = 'ST', verbose=T)
mclust::adjustedRandIndex(seu$spatial.drsc.cluster, seu$true_clusters)
library(DR.SC)
library(DR.SC)
library(DR.SC)
?Find
?FindSVGs
library(DR.SC)
## we generate the spatial transcriptomics data with lattice neighborhood, i.e. ST platform.
seu <- gendata_RNAExp(height=10, width=10,p=50, K=4)
library(Seurat)
seu <- NormalizeData(seu)
# choose spatially variable features
seu <- FindSVGs(seu)
seu
topSVGs(seu)
# Test functions ----------------------------------------------------------
### Given K
seu <- gendata_RNAExp(height=30, width=30,p=500, K=4,platform="ST")
library(Seurat)
seu <- NormalizeData(seu)
pos <- as.matrix(cbind(seu$row, seu$col))
library(DR.SC)
Adj_sp <- getAdj(seu, platform = 'ST')
Adj_sp <- getAdj(seu, platform = 'Seqscope')
Adj_sp <- getAdj(seu, platform = 'slide-seqv2')
DR.SC:::getneighborhood_fast(cbind(1:4,2:5),10)
# choose 400 highly variable features
seu <- FindVariableFeatures(seu, nfeatures = 400)
seu <- DR.SC(seu, K=NULL,K_set=2:3,  parallel="parallel", platform = 'ST', verbose=T)
seu <- DR.SC(seu, K=7, platform = 'seqscope', verbose=T)
seu <- DR.SC(seu, K=7, platform = 'ST', verbose=T)
seu <- DR.SC(seu, K=7, platform = 'scRNAseq', verbose=T)
mclust::adjustedRandIndex(seu$spatial.drsc.cluster, seu$true_clusters)
seu@tools$icMat
seu@tools$K_best
seu@tools
# Visualization -----------------------------------------------------------
features <- c("gene-24","gene-68", "gene-95","gene-55")
RidgePlot(seu, features = features, ncol = 2)
### chooose 2000 spatially variables genes
seu <- FindSVGs(hcc1, nfeatures = 4000)
x <- c(2,3,1)
order(x)
sort(x)
x <- c(0.2, 0.1, 0.3)
names(x) <- paste0('gene', 1:3)
x
order(x)
genes <- names(x)[order(x)]
genes
x[order(x)]
library(DR.SC)
