mclust::adjustedRandIndex(seu$spatial.drsc.cluster, seu$true_clusters)
library(DR.SC)
library(DR.SC)
library(DR.SC)
?Find
?FindSVGs
library(DR.SC)
## we generate the spatial transcriptomics data with lattice neighborhood, i.e. ST platform.
seu <- gendata_RNAExp(height=10, width=10,p=50, K=4)
library(Seurat)
seu <- NormalizeData(seu)
# choose spatially variable features
seu <- FindSVGs(seu)
seu
topSVGs(seu)
# Test functions ----------------------------------------------------------
### Given K
seu <- gendata_RNAExp(height=30, width=30,p=500, K=4,platform="ST")
library(Seurat)
seu <- NormalizeData(seu)
pos <- as.matrix(cbind(seu$row, seu$col))
library(DR.SC)
Adj_sp <- getAdj(seu, platform = 'ST')
Adj_sp <- getAdj(seu, platform = 'Seqscope')
Adj_sp <- getAdj(seu, platform = 'slide-seqv2')
DR.SC:::getneighborhood_fast(cbind(1:4,2:5),10)
# choose 400 highly variable features
seu <- FindVariableFeatures(seu, nfeatures = 400)
seu <- DR.SC(seu, K=NULL,K_set=2:3,  parallel="parallel", platform = 'ST', verbose=T)
seu <- DR.SC(seu, K=7, platform = 'seqscope', verbose=T)
seu <- DR.SC(seu, K=7, platform = 'ST', verbose=T)
seu <- DR.SC(seu, K=7, platform = 'scRNAseq', verbose=T)
mclust::adjustedRandIndex(seu$spatial.drsc.cluster, seu$true_clusters)
seu@tools$icMat
seu@tools$K_best
seu@tools
# Visualization -----------------------------------------------------------
features <- c("gene-24","gene-68", "gene-95","gene-55")
RidgePlot(seu, features = features, ncol = 2)
### chooose 2000 spatially variables genes
seu <- FindSVGs(hcc1, nfeatures = 4000)
x <- c(2,3,1)
order(x)
sort(x)
x <- c(0.2, 0.1, 0.3)
names(x) <- paste0('gene', 1:3)
x
order(x)
genes <- names(x)[order(x)]
genes
x[order(x)]
library(DR.SC)
library(DR.SC)
library(DR.SC)
?FindVariableFeatures
library(DR.SC)
?parallel::mclapply
# Test functions ----------------------------------------------------------
### Given K
seu <- gendata_RNAExp(height=30, width=30,p=500, K=4,platform="ST")
# Test functions ----------------------------------------------------------
library(DR.SC)
### Given K
seu <- gendata_RNAExp(height=30, width=30,p=500, K=4,platform="ST")
library(Seurat)
seu <- NormalizeData(seu)
pos <- as.matrix(cbind(seu$row, seu$col))
Adj_sp <- getAdj(seu, platform = 'ST')
Adj_sp <- getAdj(seu, platform = 'Seqscope')
Adj_sp <- getAdj(seu, platform = 'slide-seqv2')
DR.SC:::getneighborhood_fast(cbind(1:4,2:5),10)
# choose 400 highly variable features
seu <- FindVariableFeatures(seu, nfeatures = 400)
seu <- DR.SC(seu, K=NULL,K_set=2:3,  parallel="parallel", platform = 'ST', verbose=T)
paste0(K_set, "  ")
K_set = seq(2, 10)
paste0(K_set, "  ")
message("The candidate set is: ", paste0(K_set, "  "), '\n')
message("The candidate set is: ", paste0(K_set, " "), '\n')
str(seu)
seu
seu[['RNA']]@data
is.null(seu[[assy]]@data
)
assy <- DefaultAssay(seu)
is.null(seu[[assy]]@data)
class(seu[[assy]]@data)
library(DR.SC)
seu <- DR.SC(seu, K=7, platform = 'seqscope', verbose=T)
seu <- DR.SC(seu, K=7, platform = 'ST', verbose=T)
?getAdj_auto
library(DR.SC)
seu <- DR.SC(seu, K=7, platform = 'seqscope', verbose=T)
seu <- DR.SC(seu, K=7, platform = 'seqscope', verbose=F)
?Mclust
### This function includes the main methods: first is simultaneous dimension reduction and
### clustering with homo variance error and no sptial information, second is the
### simulDRcluster with heter variance and no spatial information, and third is the
### simulDRcluster with heter variance and spatial information
simulDRcluster <- function(X,Adj_sp = NULL, q, K, error.heter= TRUE, beta_grid=seq(0.5, 5, by=0.5),
maxIter=30, epsLogLik=1e-5, verbose=FALSE, maxIter_ICM=6,pen.const=0.5,
alpha=FALSE, wpca.int=TRUE, diagSigmak=FALSE){
n <- nrow(X); p <- ncol(X)
X <- scale(X, scale=FALSE)
if(verbose){
message("-------------------Calculate inital values------------- \n")
}
# require(mclust)
tic <- proc.time()
princ <- wpca(X, q, weighted=wpca.int)
if(error.heter){
Lam_vec0 <- princ$Lam_vec
}else{
Lam_vec0 <- rep(mean(princ$Lam_vec), p)
}
W0 <- princ$loadings
hZ <- princ$PCs
mclus2 <- Mclust(hZ, G=K, verbose=FALSE)
toc_gmm <- proc.time() - tic
y <- mclus2$classification
if(alpha){
alpha0 <- mclus2$parameters$pro
}else{
alpha0 <- rep(0, K)
}
Mu0 <- t(mclus2$parameters$mean)
Sigma0 <- mclus2$parameters$variance$sigma
if(verbose){
message("-------------------Finish computing inital values------------- \n")
}
if(verbose){
verbose <- 1
}else{
verbose <- 0
}
if(verbose)
message("-------------------Starting  EM algortihm------------- \n")
if((!is.null(Adj_sp))){
resList <- icmem_heterCpp(X, Adj_sp, y,  Mu0, W0, Sigma0,  Lam_vec0,
alpha=alpha0,  beta_int=1.5, beta_grid=beta_grid, maxIter_ICM, maxIter,
epsLogLik, verbose, !error.heter, diagSigmak)
resList$aic <- -2.0* resList$loglik + (1+p*(q+1) + K*(q+q*(q+1)/2.0))* 2* log(log(p+n))*pen.const # adjusted  bic and aic for high dimension
resList$bic <-  -2.0* resList$loglik + (1+p*(q+1) + K*(q+q*(q+1)/2.0))* log(n)* log(log(p+n))*pen.const
}else if(is.null(Adj_sp)){
alpha0 <- mclus2$parameters$pro
resList <- EMmPCpp_heter(X, alpha0, Mu0, W0,Sigma0, Lam_vec0,maxIter, epsLogLik,
verbose, !error.heter, diagSigmak)
resList$aic <- -2.0* resList$loglik + (1+p*(q+1) + K*(q+q*(q+1)/2.0))* 2* log(log(p+n))*pen.const # adjusted  bic and aic for high dimension
resList$bic <-  -2.0* resList$loglik + (1+p*(q+1) + K*(q+q*(q+1)/2.0))* log(n)* log(log(p+n)) *pen.const
}
toc_heter <- proc.time() - tic
if(verbose) {
message("-------------------Complete!------------- \n")
message("elasped time is :", toc_heter[3], '\n')
}
resList$cluster_init <- y
time_used <- c(toc_gmm[3], toc_heter[3])
names(time_used) <- c("pcgmm", "simul")
resList$time <- time_used
return(resList)
}
seu <- DR.SC(seu, K=7, platform = 'ST', verbose=T)
library(DR.SC)
mclust::adjustedRandIndex(seu$spatial.drsc.cluster, seu$true_clusters)
seu <- DR.SC(seu, K=7, platform = 'ST', verbose=T)
library(DR.SC)
seu <- DR.SC(seu, K=7, platform = 'ST', verbose=T)
mclust::adjustedRandIndex(seu$spatial.drsc.cluster, seu$true_clusters)
# Visualization -----------------------------------------------------------
features <- c("gene-24","gene-68", "gene-95","gene-55")
RidgePlot(seu, features = features, ncol = 2)
# Visualization -----------------------------------------------------------
library(Seurat)
features <- c("gene-24","gene-68", "gene-95","gene-55")
RidgePlot(seu, features = features, ncol = 2)
seu[1:2,1:3]
features <- c("gene_24","gene-68", "gene-95","gene-55")
RidgePlot(seu, features = features, ncol = 2)
features <- c("gene24","gene-68", "gene-95","gene-55")
RidgePlot(seu, features = features, ncol = 2)
features <- c("gene24","gene68", "gene95","gene55")
RidgePlot(seu, features = features, ncol = 2)
seu <- DR.SC(seu, K=7, platform = 'scRNAseq', verbose=T)
mclust::adjustedRandIndex(seu$spatial.drsc.cluster, seu$true_clusters)
library(DR.SC)
seu <- DR.SC(seu, K=7, platform = 'scRNAseq', verbose=T)
seu <- DR.SC(seu, K=7, platform = 'scRNAseq', verbose=T)
library(DR.SC)
seu <- DR.SC(seu, K=7, platform = 'scRNAseq', verbose=T)
seu <- DR.SC(seu, K=7, platform = 'ST', verbose=T)
library(DR.SC)
mclust::adjustedRandIndex(seu$spatial.drsc.cluster, seu$true_clusters)
seu <- DR.SC(seu, K=7, platform = 'scRNAseq', verbose=T)
mclust::adjustedRandIndex(seu$spatial.drsc.cluster, seu$true_clusters)
# Test functions ----------------------------------------------------------
library(DR.SC)
seu <- DR.SC(seu, K=7, platform = 'seqscope', verbose=F)
seu <- DR.SC(seu, K=7, platform = 'scRNAseq', verbose=T)
library(DR.SC)
seu <- DR.SC(seu, K=7, platform = 'scRNAseq', verbose=T)
mclust::adjustedRandIndex(seu$spatial.drsc.cluster, seu$true_clusters)
seu <- DR.SC(seu, K=7, platform = 'ST', verbose=T)
mclust::adjustedRandIndex(seu$spatial.drsc.cluster, seu$true_clusters)
library(DR.SC)
seu <- gendata_RNAExp(height=30, width=30,p=500, K=4)
head(seu@meta.data)
### Given K
library(Seurat)
seu <- NormalizeData(seu)
# choose 2000 variable features using Seurat
seu <- FindVariableFeatures(seu, nfeatures = 400)
seu2 <- DR.SC(seu, K=4, platform = 'ST', verbose=F)
mclust::adjustedRandIndex(seu2$spatial.drsc.cluster, seu$true_clusters)
spatialPlotClusters(seu2)
drscPlot(seu2)
?DR.SC
genes <- c("gene24","gene68", "gene95","gene55")
RidgePlot(seu2, features = genes, ncol = 2)
VlnPlot(seu2, features = genes, ncol=2)
seu2 <- RunTSNE(seu2, reduction="dr-sc", reduction.key='drsc_tSNE_')
FeaturePlot(seu2, features = genes, reduction = 'tsne' ,ncol=2)
DotPlot(seu2, features = genes)
# standard scaling (no regression)
seu2 <- ScaleData(seu2)
DoHeatmap(subset(seu2, downsample = 500), features = genes, size = 5)
Idents(seu2)
dat <- FindAllMarkers(seu2)
suppressPackageStartupMessages(library(dplyr) )
dat %>%group_by(cluster) %>%
top_n(n = 10, wt = avg_log2FC) -> top10
top10
dat %>%group_by(cluster) %>%
top_n(n = 2, wt = avg_log2FC) -> top10
dat %>%group_by(cluster) %>%
top_n(n = 2, wt = avg_log2FC) -> top2
top2
top
dat %>%group_by(cluster) %>%
top_n(n = 1, wt = avg_log2FC) -> top # Find the top 1 marker genes
top
genes <- top$gene
RidgePlot(seu2, features = genes, ncol = 2)
VlnPlot(seu2, features = genes, ncol=2)
seu2 <- RunTSNE(seu2, reduction="dr-sc", reduction.key='drsc_tSNE_')
seu2 <- RunTSNE(seu2, reduction="dr-sc", reduction.key='drsctSNE_')
FeaturePlot(seu2, features = genes, reduction = 'tsne' ,ncol=2)
DotPlot(seu2, features = genes)
# standard scaling (no regression)
seu2 <- ScaleData(seu2)
DoHeatmap(subset(seu2, downsample = 500), features = genes, size = 5)
### Given K
seu <- NormalizeData(seu)
# choose 400 spatially variable features using FindSVGs
seus <- FindSVGs(seu, nfeatures = 400, verbose = F)
### Given K
seu <- NormalizeData(seu, verbose=F)
seus
seu2 <- DR.SC(seu, K=4, platform = 'ST',variable.type='SVGs', verbose=F)
seu2 <- DR.SC(seus, K=4, platform = 'ST',variable.type='SVGs', verbose=F)
mclust::adjustedRandIndex(seu2$spatial.drsc.cluster, seu$true_clusters)
spatialPlotClusters(seu2)
drscPlot(seu2)
drscPlot(seu2, visu.method = 'UMAP')
seu2 <- DR.SC(seus, q=10, K=NULL, K_set =2:6, platform = 'ST', variable.type='SVGs', verbose=F)
mbicPlot(seu2)
drscPlot(seu2)
# standard scaling (no regression)
dat %>%group_by(cluster) %>%
top_n(n = 30, wt = avg_log2FC) -> top
genes <- top$gene
seu2 <- ScaleData(seu2)
DoHeatmap(subset(seu2, downsample = 500), features = genes, size = 5)
seu2['RNA']
seu2
seu2[['RNA']]
genes <- intersect(top$gene, topSVGs(seu2, 400))
genes <- intersect(top$gene, topSVGs(seu2, 400))
seu2 <- ScaleData(seu2, verbose = F)
DoHeatmap(subset(seu2, downsample = 500), features = genes, size = 5)
seu2[['RNA']]@var.features
## Change the HVGs to SVGs
seu2[['RNA']]@var.features <- topSVGs(seu2, 400)
seu2 <- ScaleData(seu2, verbose = F)
DoHeatmap(subset(seu2, downsample = 500), features = genes, size = 5)
seu2
?FindAllMarkers
seu[[assy]]@meta.features
seu[[assy]]@meta.features$is.SVGs
seu <- FindSVGs(seu, nfeatures = nfeatures)
library(DR.SC)
seu <- gendata_RNAExp(height=30, width=30,p=500, K=4)
seu
### Given K
seu <- NormalizeData(seu, verbose=F)
# choose 400 spatially variable features using FindSVGs
seus <- FindSVGs(seu, nfeatures = 400, verbose = F)
seus
FindSVGs
# Data prepocessing -------------------------------------------------------
## use SPARK to choose spatially variable genes
FindSVGs <- function(seu, nfeatures=2000, covariates=NULL, num_core=1, verbose=TRUE){
if (!inherits(seu, "Seurat"))
stop("method is only for Seurat objects")
# require(SPARK)
# require(Seurat)
assy <- DefaultAssay(seu)
sp_count <- seu[[assy]]@counts
if(nrow(sp_count)>5000){
seu <- FindVariableFeatures(seu, nfeatures = 5000, verbose=verbose)
sp_count <- seu[[assy]]@counts[seu[[assy]]@var.features,]
}
location <- as.data.frame(cbind(seu$row, seu$col))
if(verbose){
message("Find the spatially variables genes by SPARK-X...\n")
}
sparkX <- sparkx(sp_count,location, X_in = covariates, numCores=num_core, option="mixture",  verbose=verbose)
if(nfeatures > nrow(sp_count)) nfeatures <- nrow(sp_count)
## Find top nfeatures smallest adjusted p-values
order_nfeatures <- order(sparkX$res_mtest$adjustedPval)[1:nfeatures]
genes <- row.names(sp_count)[order_nfeatures]
## Access the gene based on gene name
is.SVGs <- rep(FALSE, nrow(seu))
order.SVGs <- rep(NA, nrow(seu))
adjusted.pval.SVGs <- rep(NA, nrow(seu))
names(is.SVGs) <- names(order.SVGs)<- names(adjusted.pval.SVGs) <- row.names(seu)
order.SVGs[genes] <- 1:length(genes)
is.SVGs[genes] <- TRUE
adjusted.pval.SVGs[genes] <- sparkX$res_mtest$adjustedPval[order_nfeatures]
seu[[assy]]@meta.features$is.SVGs <- is.SVGs
seu[[assy]]@meta.features$order.SVGs <- order.SVGs
seu[[assy]]@meta.features$adjusted.pval.SVGs <- adjusted.pval.SVGs
seu[[assy]]@var.features <- genes
seu
}
# choose 400 spatially variable features using FindSVGs
seus <- FindSVGs(seu, nfeatures = 400, verbose = F)
library(DR.SC)
seu <- gendata_RNAExp(height=30, width=30,p=500, K=4)
### Given K
seu <- NormalizeData(seu, verbose=F)
# choose 400 spatially variable features using FindSVGs
seus <- FindSVGs(seu, nfeatures = 400, verbose = F)
rm(FindSVGs)
# choose 400 spatially variable features using FindSVGs
seus <- FindSVGs(seu, nfeatures = 400, verbose = F)
seus
seu2 <- DR.SC(seus, K=4, platform = 'ST',variable.type='SVGs', verbose=F)
dat <- FindAllMarkers(seu2)
suppressPackageStartupMessages(library(dplyr) )
# Find the top 1 marker genes, user can change n to access more marker genes
dat %>%group_by(cluster) %>%
top_n(n = 1, wt = avg_log2FC) -> top
genes <- top$gene
RidgePlot(seu2, features = genes, ncol = 2)
# standard scaling (no regression)
dat %>%group_by(cluster) %>%
top_n(n = 30, wt = avg_log2FC) -> top
genes <- top$gene
## Change the HVGs to SVGs
# seu2[['RNA']]@var.features <- topSVGs(seu2, 400)
seu2 <- ScaleData(seu2, verbose = F)
DoHeatmap(subset(seu2, downsample = 500), features = genes, size = 5)
seu2[['RNA']]@var.features
?DoHeatmap
DoHeatmap(subset(seu2, downsample = 500),slot='data', features = genes, size = 5)
DoHeatmap(subset(seu2, downsample = 500),features = genes, size = 5)
genes <- intersect(top$gene, seu2[['RNA']]@var.features)
DoHeatmap(subset(seu2, downsample = 500),features = genes, size = 5)
ggthemes::scale_color_calc()
library("DR.SC")
detach(package:DR.SC)
library("DR.SC")
data("HCC1", package = 'DR.SC')
dim(HCC1)
library(Seurat)
# standard log-normalization
HCC1 <- NormalizeData(HCC1, verbose = F)
# choose 2000 highly variable features
seu <- FindVariableFeatures(HCC1, nfeatures = 1000, verbose = F)
### Given K
seu <- DR.SC(seu, K=6, platform = 'Visium',nfeatures=1000, variable.type = 'HVGs',verbose=F)
# choose 2000 spatially variable features
seus <- FindSVGs(seu, nfeatures = 1000)
### Given K
seus <- DR.SC(seus, K=6, platform = 'Visium', nfeatures=1000,
variable.type='SVGs', verbose=T)
spatialPlotClusters(seus)
drscPlot(seus)
genes <- top2$gene[seq(1, 12, by=2)]
RidgePlot(seus, features = genes, ncol = 2)
SVGs <- topSVGs(seus, ntop = 1000)
dat <- FindAllMarkers(seus, features = SVGs)
head(dat)
library(dplyr, verbose=F)
head(dat)
library(dplyr, verbose=F)
top2 <-  dat %>%
group_by(cluster) %>%
top_n(n = 2, wt = avg_log2FC)
top2
genes <- top2$gene[seq(1, 12, by=2)]
RidgePlot(seus, features = genes, ncol = 2)
VlnPlot(seus, features = genes, ncol=2)
VlnPlot(seus, features = genes, ncol=2)
seus <- RunTSNE(seus, reduction="dr-sc", reduction.key='drsc_tSNE_')
top20 <-  dat %>%
group_by(cluster) %>%
top_n(n = 20, wt = avg_log2FC)
genes <- top20
genes <- top20$gene
# standard scaling (no regression)
seus <- ScaleData(seus)
DoHeatmap(subset(seus, downsample = 500), features = genes, size = 5)
library(DR.SC)
### Check examples do not have errors
devtools::run_examples()
?DR.SC
## we generate the spatial transcriptomics data with lattice neighborhood, i.e. ST platform.
seu <- gendata_RNAExp(height=10, width=10,p=50, K=4,platform="ST")
library(Seurat)
seu <- NormalizeData(seu)
# choose 100 highly variable features
# seu <- FindVariableFeatures(seu, nfeatures = 100)
# maxIter = 2 is only used for illustration, and user can use default.
# seu1 <- DR.SC(seu, K=4, platform = 'ST', maxIter=2,verbose=FALSE)
# choose spatially variable features
seu <- FindSVGs(seu, nfeatures = 40)
# use SVGs to fit DR.SC model
# maxIter = 2 is only used for illustration, and user can use default.
seu1 <- DR.SC(seu, K=4,platform = 'ST', maxIter=2,variable.type = 'SVGs',verbose=FALSE)
seu1 <- DR.SC(seu, K=NULL,platform = 'ST', maxIter=2,variable.type = 'SVGs',verbose=FALSE)
seu1
Idents(sseu)
Idents(seu1)
?DR.SC_fit
seu <- gendata_RNAExp(height=10, width=10,p=50, K=4)
library(Seurat)
seu <- NormalizeData(seu)
# choose 40 highly variable features using FindVariableFeatures in Seurat
# seu <- FindVariableFeatures(seu, nfeatures = 40)
# or choose 40 spatailly variable features using FindSVGs in DR.SC
seu <- FindSVGs(seu, nfeatures = 40)
# users define the adjacency matrix
Adj_sp <- getAdj(seu, platform = 'ST')
var.features <- seu@assays$RNA@var.features
# maxIter = 2 is only used for illustration, and user can use default.
drscList <- DR.SC_fit(X,Adj_sp=Adj_sp ,K=4, maxIter=2, verbose=TRUE)
X <- Matrix::t(LogNormalize(seu@assays$RNA@counts[var.features,],))
# maxIter = 2 is only used for illustration, and user can use default.
drscList <- DR.SC_fit(X,Adj_sp=Adj_sp ,K=4, maxIter=2, verbose=TRUE)
library(DR.SC)
seu <- FindSVGs(seu, nfeatures = 40, verbose=FALSE)
seu <- NormalizeData(seu, verbose=FALSE)
## we generate the spatial transcriptomics data with lattice neighborhood, i.e. ST platform.
seu <- gendata_RNAExp(height=10, width=10,p=50, K=4)
library(Seurat)
seu <- NormalizeData(seu)
# choose spatially variable features
seu <- FindSVGs(seu)
topSVGs(seu)
# use SVGs to fit DR.SC model
# maxIter = 2 is only used for illustration, and user can use default.
seu1 <- DR.SC(seu, K=4,platform = 'ST', variable.type = 'SVGs',maxIter = 2,verbose=FALSE)
drscPlot(seu1)
toc <- proc.time()
toc - tic
message("Neighbors were identified for ", n_with_neighbors, " out of ",
ncol(obj), " spots.")
library(DR.SC)
library(SPARK)
?sparkx
?getAdj
?getAdj_auto
getneighborhood_fast
library(DR.SC)
?getAdj
library(DR.SC)
seu <- gendata_RNAExp(height=10, width=10,p=50, K=4)
library(Seurat)
seu <- NormalizeData(seu, verbose=FALSE)
# choose 40 highly variable features using FindVariableFeatures in Seurat
# seu <- FindVariableFeatures(seu, nfeatures = 40)
# or choose 40 spatailly variable features using FindSVGs in DR.SC
seu <- FindSVGs(seu, nfeatures = 40, verbose=FALSE)
seu <- gendata_RNAExp(height=10, width=10,p=50, K=4)
library(Seurat)
seu <- NormalizeData(seu, verbose=FALSE)
# choose 40 highly variable features using FindVariableFeatures in Seurat
# seu <- FindVariableFeatures(seu, nfeatures = 40)
# or choose 40 spatailly variable features using FindSVGs in DR.SC
seu <- FindSVGs(seu, nfeatures = 40, verbose=FALSE)
Adj_sp <- getAdj(seu, platform = 'ST')
var.features <- seu@assays$RNA@var.features
X <- Matrix::t(seu[["RNA"]]@data[var.features,])
dim(X)
# maxIter = 2 is only used for illustration, and user can use default.
drscList <- DR.SC_fit(X,Adj_sp=Adj_sp ,K=4, maxIter=2, verbose=TRUE)
?getAdj
?DR.SC
data("HCC1")
dim(HCC1)
seu <- gendata_RNAExp(height=20, width=20,p=200, K=4)
seu <- FindSVGs(seu, nfeatures=100, verbose=FALSE)
(genes <- topSVGs(seu, ntop=10))
library(DR.SC)
?aes
?aes_string
library(DR.SC)
example("mbicPlot")
example("drscPlot")
library(DR.SC)
seu@reductions
